<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>TWS API v9.72+: Connection</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="https://www.interactivebrokers.com/favicon.ico" rel="shortcut icon">
<script>
$(document).ready(function(){
		var picked=getCookie("picked");
		if (picked != "") {
			if (!$(this).hasClass("active")) {
				var tabNum = $(this).index();
				var nthChild = picked;
				$("ul#tabs li.active").removeClass("active");
				$(this).addClass("active");
				$("ul#tab li.active").removeClass("active");
				$("ul#tab li:nth-child("+nthChild+")").addClass("active");
				$("ul#tabs li:nth-child("+nthChild+")").addClass("active");
				setCookie("picked", nthChild, 1);
			}
		}
		$("ul#tabs li").click(function(e){
			if (!$(this).hasClass("active")) {
			var tabNum = $(this).index();
			var nthChild = tabNum+1;
			$("ul#tabs li.active").removeClass("active");
			$(this).addClass("active");
			$("ul#tab li.active").removeClass("active");
			$("ul#tab li:nth-child("+nthChild+")").addClass("active");
			setCookie("picked", nthChild, 1);
		}
    });
});
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays*24*60*60*1000));
    var expires = "expires="+d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
} 
function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1);
        if (c.indexOf(name) == 0) return c.substring(name.length,c.length);
    }
    return "";
} 
function checkCookie() {
    var picked=getCookie("picked");
    if (picked != "") {
        alert("Welcome again " + picked);
    }else{
        //username = prompt("Please enter your name:", "");
        if (picked != "" && picked != null) {
            setCookie("picked", 1, 365);
        }
    }
}
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ib_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea" style="background-color:black;">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="nav_iblogo.png"/></a></td>
  <td style="padding: 0 0 0 1em;">
   <ul id="tabs"><li class="active">C#</li><li>Java</li><li>VB</li><li>C++</li><li>Python</li></ul>
  </td>
  <td><a href="https://www.interactivebrokers.com/en/index.php?f=customerService&p=email" style="color:#C7C7C7;font-weight:bold;padding: 0 0 0 1em;">Contact us</a></td>
  <!--BEGIN GCS_SEARCHBOX-->
  <td style="position: absolute; right: 0;">
   <div id="google-custom-search" align="right" style="vertical-align: top;">
   <script>
  (function() {
    var cx = '002885114636493240026:q6smajphkxq';
	var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
	</script>
	<gcse:search newWindow="false" enableHistory="true"></gcse:search>
   </div>
   </td>
  <!--END !GCS_SEARCHBOX-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('connection.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Connection </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A TCP connection between your API client application and the TWS needs to be established via the <a class="el" href="classIBApi_1_1EClientSocket.html#a315a7f7a34afc504d84c4f0ca462d924">IBApi.EClientSocket.eConnect</a> function. The TWS can be considered like a server actively listening for incoming connection requests on a given port. Note that the TWS can accept up to <b>32 different client applications</b> simultaneously each of them identified by a unique client Id.</p>
<h1><a class="anchor" id="connect"></a>
Connecting</h1>
<p>Once our two main objects have been created, the client application can then connect via the <a class="el" href="classIBApi_1_1EClientSocket.html">IBApi.EClientSocket</a> object:</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">            clientSocket.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7497, 0);</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        m_client.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7497, 0);</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        socketClient.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7497, 0)</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> bRes = m_pClient-&gt;eConnect( host, port, clientId, m_extraAuth);</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;        app.connect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, args.port, clientId=0)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;        print(<span class="stringliteral">&quot;serverVersion:%s connectionTime:%s&quot;</span> % (app.serverVersion(),</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                                                      app.twsConnectionTime()))</div>
</div><!-- fragment -->  </li>
</ul>
<h1><a class="anchor" id="connect_ack"></a>
Acknowledging the connection</h1>
<p>After the socket connection is established between the TWS and the client, both applications need to exchange important information such as their respective versions and in the case of the client application, its unique client Id. The API program can connect in an 'async' mode, in which the <a class="el" href="classIBApi_1_1EClient.html#acf1370a40894c7a3d44053142077397b">IBApi.EClientSocket.startApi</a> method is not immediately invoked following the socket connection, or the far more common 'synchronous' mode in which <a class="el" href="classIBApi_1_1EClient.html#acf1370a40894c7a3d44053142077397b">IBApi.EClientSocket.startApi</a> method is immedaitely invoked. If the client application decides to connect asynchronously, it will have to wait for an acknowledgement from the TWS before attempting to send the information described at the beginning of this paragraph. This acknowledgement is received via the <a class="el" href="interfaceIBApi_1_1EWrapper.html#af9a662ffc740646d319356f65725f15f">IBApi.EWrapper.connectAck</a> method. When this event is triggered within an asynchronous context, the client application will have to start the flow of information to the TWS via the <a class="el" href="classIBApi_1_1EClient.html#acf1370a40894c7a3d44053142077397b">IBApi.EClientSocket.startApi</a> method.</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>EWrapperImpl : EWrapper </div>
<div class="line">    {</div>
</div><!-- fragment --> ... <div class="fragment"><div class="line">        <span class="keyword">public</span> <span class="keywordtype">void</span> connectAck()</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (ClientSocket.AsyncEConnect)</div>
<div class="line">                ClientSocket.startApi();</div>
<div class="line">        }</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>EWrapperImpl <span class="keyword">implements</span> EWrapper {</div>
</div><!-- fragment --> ... <div class="fragment"><div class="line">    @Override</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> connectAck() {</div>
<div class="line">        <span class="keywordflow">if</span> (clientSocket.isAsyncEConnect()) {</div>
<div class="line">            System.out.println(<span class="stringliteral">&quot;Acknowledging connection&quot;</span>);</div>
<div class="line">            clientSocket.startAPI();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        Public Sub connectAck() Implements IBApi.EWrapper.connectAck</div>
<div class="line">            Console.WriteLine(&quot;ConnectAck&quot;)</div>
<div class="line">            If socketClient.AsyncEConnect Then</div>
<div class="line">                socketClient.startApi()</div>
<div class="line">            End If</div>
<div class="line">        End Sub</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line"><span class="keyword">class </span>TestCppClient : <span class="keyword">public</span> EWrapper</div>
<div class="line">{</div>
</div><!-- fragment --> ... <div class="fragment"><div class="line"><span class="keywordtype">void</span> TestCppClient::connectAck() {</div>
<div class="line">    <span class="keywordflow">if</span> (!m_extraAuth &amp;&amp; m_pClient-&gt;asyncEConnect())</div>
<div class="line">        m_pClient-&gt;startApi();</div>
<div class="line">}</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">class </span>TestWrapper(wrapper.EWrapper):</div>
</div><!-- fragment --> ... <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;    <span class="keyword">def </span>connectAck(self):</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;        <span class="keywordflow">if</span> self.async:</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            self.startApi()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
</div><!-- fragment -->  </li>
</ul>
<p>Note: all IB sample code connects using AsyncEConnect = False.</p>
<h1><a class="anchor" id="ereader"></a>
Consuming TWS data</h1>
<p>The final step on this procedure is to consume the incoming data within a separate execution thread. The class in charge of reading and parsing the raw messages from the TWS is the <a class="el" href="classIBApi_1_1EReader.html">IBApi.EReader</a> class and adding them to the queue. Internally, whenever there are messages ready to be consumed by the EReader object, a signal will be issued to this reading thread indicating so. The process is better illustrated through an example:</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">            <span class="comment">//Create a reader to consume messages from the TWS. The EReader will consume the incoming messages and put them in a queue</span></div>
<div class="line">            var reader = <span class="keyword">new</span> EReader(clientSocket, readerSignal);</div>
<div class="line">            reader.Start();</div>
<div class="line">            <span class="comment">//Once the messages are in the queue, an additional thread can be created to fetch them</span></div>
<div class="line">            <span class="keyword">new</span> Thread(() =&gt; { <span class="keywordflow">while</span> (clientSocket.IsConnected()) { readerSignal.waitForSignal(); reader.processMsgs(); } }) { IsBackground = <span class="keyword">true</span> }.Start();</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        <span class="keyword">final</span> EReader reader = <span class="keyword">new</span> EReader(m_client, m_signal);        </div>
<div class="line">                reader.start();</div>
<div class="line">                <span class="comment">//An additional thread is created in this program design to empty the messaging queue</span></div>
<div class="line">                <span class="keyword">new</span> Thread(() -&gt; {</div>
<div class="line">                    <span class="keywordflow">while</span> (m_client.isConnected()) {</div>
<div class="line">                        m_signal.waitForSignal();</div>
<div class="line">                        <span class="keywordflow">try</span> {</div>
<div class="line">                            reader.processMsgs();</div>
<div class="line">                        } <span class="keywordflow">catch</span> (Exception e) {</div>
<div class="line">                            System.out.println(<span class="stringliteral">&quot;Exception: &quot;</span>+e.getMessage());</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }).start();</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        <span class="stringliteral">&#39;Once the messages are in the queue, an additional thread need to fetch them</span></div>
<div class="line"><span class="stringliteral">        Dim msgThread As Thread = New Thread(AddressOf messageProcessing)</span></div>
<div class="line"><span class="stringliteral">        msgThread.IsBackground = True</span></div>
<div class="line"><span class="stringliteral">        If (wrapperImpl.serverVersion() &gt; 0) Then Call msgThread.Start()</span></div>
</div><!-- fragment --> ... <div class="fragment"><div class="line">    Private Sub messageProcessing()</div>
<div class="line">        Dim reader As EReader = New EReader(wrapperImpl.socketClient, wrapperImpl.eReaderSignal)</div>
<div class="line">        reader.Start()</div>
<div class="line">        While (wrapperImpl.socketClient.IsConnected)</div>
<div class="line">            wrapperImpl.eReaderSignal.waitForSignal()</div>
<div class="line">            reader.processMsgs()</div>
<div class="line">        End While</div>
<div class="line">    End Sub</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        m_pReader = <span class="keyword">new</span> EReader(m_pClient, &amp;m_osSignal);</div>
<div class="line">        m_pReader-&gt;start();</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;        <span class="comment">#this code is in Client::connect() so it&#39;s automatically done, no need</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;        <span class="comment"># for user to do it</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        self.reader = reader.EReader(self.conn, self.msg_queue)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        self.reader.start()   <span class="comment"># start thread</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
</div><!-- fragment -->  </li>
</ul>
<p>Now it is time to revisit the role of <a class="el" href="interfaceIBApi_1_1EReaderSignal.html">IBApi.EReaderSignal</a> initially introduced in <a class="el" href="client_wrapper.html#client_socket">The EClientSocket class</a>. As mentioned in the previous paragraph, the thread responsible for decoding and processing messages in the queue will need to be notified whenever there is information ready to be consumed. This is done via the <a class="el" href="interfaceIBApi_1_1EReaderSignal.html">IBApi.EReaderSignal</a> object we initiated within the <a class="el" href="interfaceIBApi_1_1EWrapper.html">IBApi.EWrapper</a>'s implementer.</p>
<p>The client application is now ready to work with the Trader Workstation! As soon as the connection has been fully established, you will immediately start receiving events from the TWS such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a09c07727efd297e438690ab42838d332">IBApi.EWrapper.nextValidId</a> or <a class="el" href="interfaceIBApi_1_1EWrapper.html#abd7e561f313bcc4c860074906199a46c">IBApi.EWrapper.managedAccounts</a>. In TWS (not IB Gateway) at the time of initial connection, if there is valid connection to the IB server there will also be callbacks to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi::EWrapper::error</a> with errorCode=<em>2104</em> or <em>2106</em> and messages of the type "Market Data Server is ok" to indicate there is an active connection to the IB market data server. It is best to wait until this message has been received before sending messages to TWS, since they may be dropped if there is not an active connection.</p>
<h1><a class="anchor" id="accept_connections"></a>
Accepting an API connection from TWS</h1>
<p>To prevent unwanted connections by default, the TWS is not configured to automatically accept any incoming connection request. Whenever a client application tries to connect to the TWS and the TWS is not configured to accept incoming connection requests from the host the client application is in, a prompt window will appear requiring the user to accept the connection attempt:</p>
<div class="image">
<img src="conn_prompt.png" alt="conn_prompt.png"/>
</div>
<p>To prevent the TWS from asking the end user to accept the connection, it is possible to configure it to automatically accept the connection from a trusted IP address and/or the local machine. This can easily be done via the TWS API settings:</p>
<div class="image">
<img src="tws_allow_connections.png" alt="tws_allow_connections.png"/>
</div>
<p><b>Note:</b> you have to make sure the connection has been fully established before attempting to do any requests to the TWS. Failure to do so will result in the TWS closing the connection. Typically this can be done by waiting for a callback from an event and the end of the initial connection handshake, such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a09c07727efd297e438690ab42838d332">IBApi.EWrapper.nextValidId</a> or <a class="el" href="interfaceIBApi_1_1EWrapper.html#abd7e561f313bcc4c860074906199a46c">IBApi.EWrapper.managedAccounts</a>.</p>
<p>However in rare cases in which IB Gateway or TWS has a momentarily delay in establishing connecting to the IB servers, messages sent immediately after receiving the nextValidId can be dropped and would need to be resent. The safest procedure then is to wait until callbacks have been received both for a TWS callback such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a09c07727efd297e438690ab42838d332">IBApi.EWrapper.nextValidId</a> or <a class="el" href="interfaceIBApi_1_1EWrapper.html#abd7e561f313bcc4c860074906199a46c">IBApi.EWrapper.managedAccounts</a>, and also a callback to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8">IBApi.EWrapper.error</a> with code 2104 "Market data server is ok" before sending messages across the socket.</p>
<h1><a class="anchor" id="broken"></a>
Broken API socket connection</h1>
<p>If there is a problem with the socket connection between TWS and the API client, for instance if TWS suddenly closes, this will trigger an exception in the EReader thread which is reading from the socket. This exception will also occur if an API client attempts to connect with a client ID that is already in use.</p>
<p>The socket EOF is handled slightly differently in different API languages. For instance in Java, it is caught and sent to the client application to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi::EWrapper::error</a> with errorCode 507: "Bad Message". In C# it is caught and sent to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi::EWrapper::error</a> with errorCode -1. The client application needs to handle this error message and use it to indicate that an exception has been thrown in the socket connection. Associated functions such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a9b0f099dc421e5a48ec290cab67a8ad1" title="Notifes when the API-TWS connectivity has been closed. ">IBApi::EWrapper::connectionClosed</a> and <a class="el" href="classIBApi_1_1EClient.html#ab8e2702adca8f47228f9754f4963455d" title="Notifies whether or not a socket connection exists between the API client and the Host...">IBApi::EClient::IsConnected</a> functions are not called automatically by the API code but need to be handled at the API client-level.</p>
<p><br/>
<br/>
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">This website uses cookies. By navigating through it you agree to the use of cookies. Copyright Interactive Brokers 2016 </li>
  </ul>
</div>
<!--BEGIN GCS_SEARCHBOX-->
<style type='text/css'>
	.gsc-control-cse{
		font family: Arial, sans-serif;
		border-color: #000100;
		background-color: #000000;
		width:250px;
		height: 20px;
		padding-top: 6px;
	}
	input.gsc-search-button {
		background-color: #6D1800;
		color: #fff;
		cursor: pointer;
	}
	input.gsc-search-button:hover {
		background-color: #A02200;
	}
	td.gsc-clear-button {
		position: relative;
		right: 85px;
	}
  }
</style>
<!--END GCS_SEARCHBOX-->
</body>
</html>
